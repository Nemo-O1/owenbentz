<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Owen Bentz - Cybersecurity Student</title>
    <meta name="description" content="Owen Bentz is a highly motivated cybersecurity student seeking real-world experience. Explore his resume, projects, and interests in IT and network security.">
    <meta name="keywords" content="Owen Bentz, cybersecurity, student, resume, IT, network security, computer science, ethical hacking, certifications, C++, Visual Basic, Python, Linux, Windows, macOS, Three.js, web development, Cloudflare Pages">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Roboto+Mono:wght@400;500&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css?v=1.1">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js?v=1.1"></script>
    <style>
        /* Root CSS variables for consistent theming and easy adjustments */
        :root {
            --primary-color: #FF5722; /* Main accent color */
            --secondary-color: #FF8A65; /* Secondary accent color */
            --background-dark: #1a1a1a; /* Dark background for the body */
            --background-content: rgba(26, 26, 26, 0.9); /* Slightly transparent dark background for content faces */
            --section-bg: rgba(35, 35, 35, 0.8); /* Background for collapsible sections (currently unused directly) */
            --text-color: #eee; /* Light text color for general content */
            --light-text-color: #ddd; /* Slightly lighter text color for subtle elements */
            --hover-orange: #E64A19; /* Darker orange for hover effects */
            --hobby-bg: #444; /* Background for individual hobby tags */
            --modal-bg: rgba(0,0,0,0.9); /* Dark, semi-transparent background for modals */
            --modal-close-color: #f1f1f1; /* Color for modal close button */
            --modal-close-hover: #bbb; /* Hover color for modal close button */
            
            /* Responsive sizing variables for the cube container */
            --cube-width: min(85vw, 750px);
            --cube-height: min(85vh, 750px);
            --transition-duration: 0.5s; /* Standard transition duration for cube rotation */

            /* Padding variables for absolute positioning of elements within faces */
            --face-side-padding-desktop: 35px; /* Horizontal padding for desktop */
            --face-side-padding-mobile: 20px; /* Horizontal padding for mobile */
            --face-top-padding-desktop: 120px; /* Controls header's top position from face edge (to clear dots) */
            --face-top-padding-mobile: 120px; /* Controls header's top position from face edge (to clear dots) */
            --face-bottom-padding-desktop: 80px; /* Space at the bottom of the face, below content */
            --face-bottom-padding-mobile: 80px; /* Space at the bottom of the face, below content */
            
            /* Specific gap between the bottom of the header and the top of the content area */
            --content-gap-desktop: 10px; 
            --content-gap-mobile: 10px; 
        }

        /* Universal box-sizing for consistent layout */
        * {
            box-sizing: border-box;
        }

        /* Full height for html and body, centered content, no scrollbars */
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: 'Inter', sans-serif; /* Primary font */
            background-color: var(--background-dark);
            color: var(--text-color);
            overflow: hidden; /* Prevent body scrollbars, as content has custom scrolling */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        /* Three.js scene container for background animation */
        #scene-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1; /* Place behind other content */
        }

        /* Main container for the 3D cube */
        .cube-container {
            width: var(--cube-width);
            height: var(--cube-height);
            perspective: 2200px; /* Creates the 3D depth effect */
            position: relative;
            z-index: 1; /* Place above Three.js background */
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden; /* Hide any overflow from the cube */
            margin: auto; /* Center the container */
        }

        /* The 3D cube element itself */
        .cube {
            width: 100%;
            height: 100%;
            position: relative;
            transform-style: preserve-3d; /* Enables 3D transformations for children */
            transition: transform var(--transition-duration) ease-out; /* Smooth rotation transition */
            will-change: transform; /* Optimize for animation */
        }

        /* Individual faces of the cube */
        .face {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: var(--background-content);
            border: 1px solid rgba(255, 255, 255, 0.05); /* Subtle border */
            border-radius: 12px; /* Rounded corners */
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4); /* Soft shadow */
            -webkit-overflow-scrolling: touch; /* Improves scrolling on iOS */
            overflow: hidden; /* Ensure content within face stays contained */
            will-change: transform; /* Optimize for animation */
        }

        /* Positioning for each face to form an octagonal prism (4 sides visible) */
        .face:nth-child(1) { transform: rotateY(0deg) translateZ(calc(var(--cube-width) * 0.85)); }
        .face:nth-child(2) { transform: rotateY(90deg) translateZ(calc(var(--cube-width) * 0.85)); }
        .face:nth-child(3) { transform: rotateY(180deg) translateZ(calc(var(--cube-width) * 0.85)); }
        .face:nth-child(4) { transform: rotateY(270deg) translateZ(calc(var(--cube-width) * 0.85)); }

        /* Absolute positioned header within each face */
        .face-header {
            position: absolute;
            top: var(--face-top-padding-desktop); /* Position from the top edge of the face */
            left: var(--face-side-padding-desktop);
            width: calc(100% - (2 * var(--face-side-padding-desktop))); /* Full width minus side padding */
            height: auto; /* Height determined by content */
            min-height: 0; /* Override default min-height to allow content to dictate height */
            text-align: center;
            padding-top: 0; /* Removed internal padding to reduce gap below titles */
            z-index: 2; /* Ensure header is above scrollable content */
            box-sizing: border-box;
            will-change: height, top; /* Optimize for animation */
        }

        /* Ensure no margin below headings within the header to control spacing precisely */
        .face-header h1,
        .face-header h2,
        .face-header h3 {
            margin-bottom: 0; 
        }

        /* Absolute positioned scrollable content area within each face */
        .section-content {
            position: absolute;
            /* Top will be calculated dynamically in JS based on header's actual height + content-gap */
            left: var(--face-side-padding-desktop);
            right: var(--face-side-padding-desktop);
            bottom: var(--face-bottom-padding-desktop); /* Position from the bottom edge of the face */
            
            width: auto;
            height: auto; /* Height determined by available space */

            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;

            overflow-y: hidden; /* Set to hidden as we're using custom JS scrolling */
            box-sizing: border-box;
            will-change: transform, scroll-position; /* Optimize for animation */
            
            padding-bottom: 100px; /* Added padding-bottom to ensure content pushes scrollHeight correctly */
        }

        /* General typography styles */
        h1, h2, h3 {
            color: var(--primary-color);
            text-align: center;
            font-weight: 600;
            margin-bottom: 5px; /* Default margin for headings outside .face-header */
            width: 100%;
            flex-shrink: 0; /* Prevent shrinking in flex containers */
        }

        /* Increased font sizes for better readability across devices */
        h1 { font-size: clamp(14px, 4vw, 22px); }
        h2 { font-size: clamp(12px, 3.5vw, 18px); }
        h3 { font-size: clamp(10px, 2.8vw, 14px); margin-top: 5px; }

        p, li {
            word-wrap: break-word; /* Break long words */
            overflow-wrap: break-word; /* Break long words */
            white-space: normal; /* Allow normal text wrapping */
            width: 100%;
            display: block;
        }

        /* Specific styles for contact information */
        .contact-info p {
            font-size: clamp(9px, 2.5vw, 12px); 
            display: flex;
            align-items: center;
            gap: 2px;
            line-height: 1.2; 
            margin-bottom: 2px;
            color: var(--light-text-color);
            text-align: center;
            max-width: 78%; 
            margin: 0 auto 2px auto;
        }
        .contact-info p i {
            color: var(--secondary-color);
            font-size: clamp(11px, 3vw, 14px); 
        }

        /* Styles for the intro/objective face */
        .intro-objective .section-content {
            padding-top: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .intro-objective .objective-text-container {
            margin-top: 10px;
            width: 100%;
            text-align: center;
        }
        .intro-objective .objective-text-container h2 {
            margin-bottom: 5px;
        }
        .intro-objective .objective-text-container p {
            font-family: 'Roboto Mono', monospace; /* Distinct font for objective text */
            font-size: clamp(8px, 2.2vw, 11px); 
            line-height: 1.3; 
            text-align: center;
            max-width: 60%; 
            margin: 0 auto;
        }

        /* Styles for the About Me face */
        .about-me .section-content {
            padding-top: 5px;
        }
        .about-me p { /* Paragraphs are already centered */
            font-size: clamp(10px, 2.5vw, 12px); 
            line-height: 1.4; 
            margin-bottom: 3px; 
            text-align: center;
            max-width: 75%; 
            margin: 0 auto 3px auto; 
        }
        .about-me h4 { /* New style for subtitles in About Me */
            color: var(--secondary-color);
            margin-top: 10px;
            margin-bottom: 5px;
            font-weight: 500;
            font-size: clamp(10px, 2.8vw, 14px);
            text-align: center; /* Ensure new h4 elements are centered */
            width: 100%; /* Take full width for centering */
        }
        .about-me ul {
            list-style: none; /* Remove default bullets as we're centering */
            padding: 0; /* Remove default padding */
            margin: 0 auto; /* Center the ul block */
            text-align: center; /* Center text within li elements */
            width: fit-content; /* Allow ul to shrink to content width for centering */
            max-width: 75%; /* Limit width */
        }
        .about-me ul li {
            margin-bottom: 1px; 
            font-size: clamp(10px, 2.5vw, 12px); /* Apply font size directly to li */
            line-height: 1.4;
            color: var(--text-color); /* Ensure text color is applied */
        }

        /* Styles for the Experience face */
        .experience .section-content {
            padding-top: 5px;
        }
        .experience-item {
            margin-bottom: 5px; 
            width: 100%;
            text-align: center;
        }
        .experience-item h4 {
            color: var(--secondary-color);
            margin-bottom: 0;
            font-weight: 500;
            font-size: clamp(9px, 2.5vw, 11px); 
        }
        .experience-item p {
            font-size: clamp(9px, 2.2vw, 10px); 
            line-height: 1.3; 
            margin-bottom: 0;
            max-width: 75%; 
            margin: 0 auto;
        }
        .experience-item ul {
            list-style: disc; /* Keep disc bullets */
            padding-left: 0; /* Remove default padding for centering */
            margin: 0 auto; /* Center the ul block */
            text-align: center; /* Center text within li elements */
            width: fit-content; /* Allow ul to shrink to content width for centering */
            max-width: 75%; 
        }
        .experience-item ul li {
            font-size: clamp(9px, 2.2vw, 10px); 
            line-height: 1.3; 
            margin-bottom: 1px; 
            color: var(--text-color);
            /* To visually center bullets, we might need more advanced CSS,
               but for now, centering the text within the li is the direct request. */
        }

        /* Styles for the Hobbies and PC Evolution Face */
        .hobbies-pc-evolution .section-content {
            padding-top: 5px;
        }
        .hobbies-list ul {
            list-style: none;
            padding: 0;
            display: flex;
            flex-wrap: wrap;
            gap: 3px; 
            justify-content: center; /* Already centers flex items */
            max-width: 75%; 
            margin: 0 auto 15px auto; 
        }
        .hobbies-list li {
            background-color: var(--hobby-bg);
            color: #fff;
            padding: 5px 8px; 
            border-radius: 8px; 
            font-size: clamp(7px, 1.8vw, 9px); 
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 4px; 
            cursor: pointer;
            text-align: center;
        }
        .hobbies-list li:hover {
            background-color: var(--primary-color);
            transform: translateY(-2px) scale(1.02);
            box-shadow: 0 3px 6px rgba(255, 87, 34, 0.4);
        }
        .hobbies-list li i {
            color: var(--secondary-color);
        }

        /* Styles for collapsible containers */
        .collapsible-container {
            width: 100%; 
            margin-top: 15px; 
            padding: 0 10px;
            box-sizing: border-box;
            max-width: 75%; 
            margin-left: auto; 
            margin-right: auto; 
        }

        .collapsible-header {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 10px 0; 
            background-color: rgba(68, 68, 68, 0.5);
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s ease;
            margin-bottom: 8px; 
        }

        .collapsible-header:hover {
            background-color: rgba(68, 68, 68, 0.8);
        }

        .collapsible-header h3 {
            margin: 0;
            color: var(--secondary-color);
            flex-grow: 1;
            text-align: center;
            font-size: clamp(10px, 2.8vw, 14px); 
        }

        .collapsible-icon {
            margin-left: 10px;
            color: var(--secondary-color);
            transition: transform 0.3s ease;
            font-size: clamp(11px, 3vw, 15px); 
        }

        .collapsible-icon.rotated {
            transform: rotate(90deg);
        }

        .collapsible-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.4s ease-out;
            padding: 0 10px;
            box-sizing: border-box;
        }

        .collapsible-content.active {
            max-height: 2000px; /* Sufficiently large value for smooth transition */
        }

        /* Styles for PC evolution images grid */
        .pc-evolution-images-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(50px, 1fr)); 
            gap: 5px; 
            margin-top: 8px; 
            justify-items: center;
            max-width: 75%; 
            margin: 8px auto 0 auto; 
        }
        .pc-evolution-images-grid img {
            width: 100%;
            height: clamp(25px, 6vw, 40px); 
            object-fit: cover;
            max-width: 80px; 
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            transition: transform 0.3s ease;
            cursor: pointer;
        }
        .pc-evolution-images-grid img:hover {
            transform: scale(1.05);
        }

        /* Link styling */
        a {
            color: var(--primary-color);
            text-decoration: none;
            transition: color 0.3s ease;
        }
        a:hover {
            color: var(--hover-orange);
        }

        /* Logo image styling */
        #logo-image {
            display: block;
            margin: 0 auto 10px auto; 
            width: 50px; 
            height: auto;
            flex-shrink: 0;
        }

        /* Modal overlay for image display */
        .modal {
            display: none; /* Hidden by default */
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: hidden; /* Prevent scrolling inside modal */
            background-color: var(--modal-bg);
            align-items: center;
            justify-content: center;
        }
        .modal-content {
            margin: auto;
            display: block;
            max-width: 90%;
            max-height: 90%;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.7);
            animation: zoom 0.6s; /* Zoom in animation */
        }
        @keyframes zoom {
            from { transform: scale(0.1); }
            to { transform: scale(1); }
        }
        .close-button {
            position: absolute;
            top: 15px;
            right: 35px;
            color: var(--modal-close-color);
            font-size: 40px;
            font-weight: bold;
            transition: 0.3s;
            cursor: pointer;
        }
        .close-button:hover {
            color: var(--modal-close-hover);
        }

        /* Modal navigation arrows */
        .modal-nav-arrow {
            cursor: pointer;
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            font-size: 50px;
            color: rgba(255, 255, 255, 0.8); /* Semi-transparent white */
            user-select: none; /* Prevent text selection */
            transition: 0.3s;
            z-index: 1001; /* Above modal content */
            padding: 10px;
        }
        .modal-nav-arrow:hover {
            color: var(--primary-color); /* Orange on hover */
            text-shadow: 0 0 10px var(--primary-color); /* Subtle glow on hover */
        }
        .modal-nav-arrow.left {
            left: 20px;
        }
        .modal-nav-arrow.right {
            right: 20px;
        }
        .modal-nav-arrow.disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }


        /* Navigation dots at the top of the screen */
        .nav-dots {
            position: fixed;
            top: 20px; 
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 101; /* Ensure dots are above the cube */
        }
        .dot {
            width: 12px;
            height: 12px;
            background-color: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .dot.active {
            background-color: var(--primary-color);
            transform: scale(1.2);
        }
        .dot:hover { 
            background-color: var(--hover-orange);
            transform: scale(1.3);
        }

        /* Disclaimer text at the bottom */
        .disclaimer {
            position: fixed;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            color: var(--light-text-color);
            font-size: clamp(10px, 2.5vw, 16px); 
            z-index: 100;
        }

        /* Mobile optimization for smaller screens */
        @media (max-width: 768px) {
            :root {
                --cube-width: 95vw;
                --cube-height: 95vh;
                --face-side-padding-mobile: 20px;
                --face-top-padding-mobile: 120px; 
                --face-bottom-padding-mobile: 80px; 
                --content-gap-mobile: 10px; 
            }

            .face-header {
                min-height: 0; 
                padding-top: 0; 
                left: var(--face-side-padding-mobile);
                width: calc(100% - (2 * var(--face-side-padding-mobile)));
            }
            .section-content {
                left: var(--face-side-padding-mobile);
                right: var(--face-side-padding-mobile);
                bottom: var(--face-bottom-padding-mobile);
            }
            
            /* Adjust clamp values for mobile for better control */
            h1 { font-size: 14px; }
            h2 { font-size: 12px; }
            h3 { font-size: 10px; margin-top: 1px;}

            .contact-info p {
                font-size: 9px;
                gap: 1px;
                max-width: 82%; 
            }
            .contact-info p i {
                font-size: 11px;
            }

            .intro-objective .objective-text-container p {
                font-size: 8px;
                max-width: 70%; 
            }

            .about-me p, .about-me ul {
                font-size: 10px;
                max-width: 85%; 
            }
            .about-me ul {
                padding-left: 3px;
            }

            .experience-item h4 {
                font-size: 9px;
            }
            .experience-item p {
                font-size: 9px;
                max-width: 85%; 
            }
            .experience-item ul {
                padding-left: 2px;
                max-width: 85%; 
            }
            .experience-item ul li {
                font-size: 9px;
            }

            .hobbies-list li {
                font-size: 7px;
                padding: 3px 5px; 
                border-radius: 5px; 
                gap: 2px; 
            }

            .hobbies-list ul {
                max-width: 85%; 
            }

            .collapsible-container {
                max-width: 85%; 
            }

            .pc-evolution-images-grid {
                grid-template-columns: repeat(auto-fit, minmax(25px, 1fr)); 
                gap: 2px; 
                max-width: 85%; 
            }
            .pc-evolution-images-grid img {
                height: 25px; 
            }

            /* Modal navigation arrows for mobile */
            .modal-nav-arrow {
                font-size: 30px; /* Smaller arrows for mobile */
                left: 10px; /* Closer to edges */
                right: 10px;
            }
        }
    </style>
</head>
<body>
    <div id="scene-container"></div>

    <div class="cube-container" id="cube-container">
        <div class="cube" id="resume-cube">
            <div class="face face-0 intro-objective">
                <div class="face-header">
                    <img id="logo-image" src="images/01-logo3.png" alt="01 Logo" onerror="this.onerror=null;this.src='https://placehold.co/150x50/222/FFF?text=Logo+Error';">
                    <h1>Owen James Engebretson Bentz</h1>
                </div>
                <section class="section-content contact-info">
                    <p><i class="fas fa-globe"></i> <strong>URL:</strong> <a href="https://owenbentz.org/">https://owenbentz.org/</a></p>
                    <p><i class="fas fa-envelope"></i> <strong>Email:</strong> <a href="mailto:owenbentz01@gmail.com">owenbentz01@gmail.com</a></p>
                    <p><i class="fas fa-phone"></i> <strong>Phone:</strong> 612-701-4335</p>
                    <p><i class="fas fa-calendar-alt"></i> <strong>DoB:</strong> 01-24-2003</p>
                    
                    <div class="objective-text-container">
                        <h2>Objective</h2>
                        <p id="objective-text">Highly motivated aspiring cybersecurity student seeking to leverage my skills and passion in a real-world, relevant job setting.</p>
                    </div>
                </section>
            </div>
            <div class="face face-1">
                <div class="face-header">
                    <h2>Experience</h2>
                </div>
                <section class="section-content experience">
                    <div class="experience-item">
                        <h4>Pizza Ranch</h4>
                        <p>Casper, WY (2017-2019)</p>
                        <p>Cook, Kitchen Staff</p>
                        <p>Commitment to customer service and food industry</p>
                    </div>
                    <div class="experience-item">
                        <h4>Spark DDI Delivery</h4>
                        <p>Casper, WY (2020-2025)</p>
                        <p>Package Delivery Personnel</p>
                        <p>Demonstrated reliability and time management skills.</p>
                    </div>
                    <div class="experience-item">
                        <h4>Cybersecurity & Network Operations Specialist (in a simulated setting)</h4>
                        <ul>
                            <li>Practice in advanced switch and router configurations, OSI model, subnetting, IPv4/IPv6, TCP/UDP, VLAN segmentation, and networking troubleshooting.</li>
                        </ul>
                    </div>
                    <div class="experience-item">
                        <h4>Advanced Network Security Analyst</h4>
                        <ul>
                            <li>Robust understanding of offensive and defensive cybersecurity strategies, including network defense mechanisms and identifying attack vectors, vulnerability response, malware protection, firewall configuration, ACLs, URL blocking, forensic drive image analysis, and encryption.</li>
                            <li>Skilled in user account policies, social engineering, and phishing tactics.</li>
                            <li>Experienced in detecting DNS tunneling, DDOS attacks, open port scanning, DHCP attacks, etc.</li>
                            <li>Ample practice in Wireshark, Ettercap, Burp Suite, Nmap, Metasploit, honeypots, firewalls and OSINT.</li>
                        </ul>
                    </div>
                    <div class="experience-item">
                        <h4>IT & Systems Administrator</h4>
                        <ul>
                            <li>Proficient in managing Linux environments, macOS, and Windows (user security policies configuration).</li>
                            <li>Practice in VMware and VirtualBox.</li>
                            <li>Accomplished in Excel, Word, and Access.</li>
                            <li>Substantial Photoshop and video editing abilities.</li>
                        </ul>
                    </div>
                </section>
            </div>
            <div class="face face-2">
                <div class="face-header">
                    <h2>About Me</h2>
                </div>
                <section class="section-content about-me">
                    <h4 style="color: var(--secondary-color);">Location History:</h4>
                    <ul>
                        <li>Born in Burnsville, Minnesota</li>
                        <li>Raised in Morristown, Minnesota</li>
                        <li>Moved to Faribault, Minnesota in 2015</li>
                        <li>Moved to Casper, Wyoming in 2017</li>
                        <li><span style="color: var(--secondary-color);">Currently a student at Casper College, pursuing an associate's degree in Computer Security</span></li>
                    </ul>
                    <p>
                        My attraction to this field stems from my experience as the go-to IT support for family and friends. I genuinely enjoy helping others resolve their technical issues and find the troubleshooting process to be rewarding. My family has been a constant source of encouragement, wholeheartedly supporting my interests.
                    </p>
                    <p>
                        I'm a highly motivated aspiring cybersecurity enthusiast with a lifelong passion for technology. From building my first gaming rig at 14, to mastering network configurations, my passion for the digital world is unwavering.
                    </p>
                    <h4 style="color: var(--secondary-color);">My strengths include:</h4>
                    <ul>
                        <li>Possessing a solid understanding of operating systems, network security, and proactive threat detection.</li>
                        <li>Background in creative software and analytical troubleshooting providing a unique and valuable perspective to the cybersecurity landscape.</li>
                        <li>Eager to contribute a dynamic approach to protecting digital assets and infrastructure.</li>
                        <li>Seeking to leverage my proven work ethic and IT passion into a dedicated IT role.</li>
                    </ul>
                    <h4 style="color: var(--secondary-color);">*</h4>
                    <p>
                        While the majority of my knowledge is self-taught, driven by curiosity and desire to learn, I owe significant credit to my family (Mom: Jen, Dad: Brad, Brother: Riley), my Kelly Walsh CCNA teacher, Duane Reimer, and my Casper College CCNA instructor, Jeffrey Brewster, for their invaluable contributions. I am currently preparing to take the CCNA exam upon completion of my CCNA prep course at Casper College.
                    </p>
                    <h4 style="color: var(--secondary-color);">AI</h4>
                    <p>In my opinion, AI is a powerful tool with vast potential for automating tasks and enhancing various processes. I believe it is crucial to learn how to effectively utilize these tools while maintaining an awareness of their distinction from human-generated content. (In fact, this website was built using contributions from Gemini 2.0).</p>
                </section>
            </div>
            <div class="face face-3 hobbies-pc-evolution">
                <div class="face-header">
                    <h2>Hobbies & Interests</h2>
                </div>
                <section class="section-content hobbies">
                    <div class="collapsible-container" id="mainHobbiesCollapsible">
                        <div class="collapsible-header" id="mainHobbiesHeader">
                            <h3>My Hobbies</h3>
                            <i class="fas fa-chevron-right collapsible-icon" id="mainHobbiesIcon"></i>
                        </div>
                        <div class="collapsible-content" id="mainHobbiesContent"> 
                            <div class="hobbies-list">
                                <ul>
                                    <li><i class="fas fa-desktop"></i> Building Custom PCs</li>
                                    <li><i class="fas fa-shield-alt"></i> Cybersecurity News</li>
                                    <li><i class="fas fa-unlock-alt"></i> Jailbreaking (LLMs, iOS)</li>
                                    <li><i class="fas fa-server"></i> OS, Virtual Machines</li>
                                    <li><i class="fas fa-network-wired"></i> Network Configuration</li>
                                    <li><i class="fas fa-wrench"></i> Common IT Troubleshooting</li>
                                    <li><i class="fas fa-gamepad"></i> Gaming</li>
                                    <li><i class="fas fa-lightbulb"></i> Staying Updated on Tech Advances (CRISPR, Neuralink, LLMs)</li>
                                    <li><i class="fas fa-microchip"></i> Computer Hardware</li>
                                    <li><i class="fas fa-chart-line"></i> Nvidia GPU Releases</li>
                                    <li><i class="fas fa-code"></i> Software</li>
                                    <li><i class="fas fa-robot"></i> Artificial Intelligence</li>
                                    <li><i class="fas fa-podcast"></i> Podcasts</li>
                                    <li><i class="fas fa-cube"></i> Rubik's Cubes</li>
                                    <li><i class="fas fa-puzzle-piece"></i> Puzzles</li>
                                    <li><i class="fas fa-car"></i> Cars</li>
                                    <li><i class="fas fa-motorcycle"></i> Dirt Bikes</li>
                                    <li><i class="fas fa-paint-brush"></i> Art</li>
                                    <li><i class="fas fa-film"></i> Movies</li>
                                </ul>
                            </div>
                        </div>
                    </div>

                    <div class="collapsible-container" id="pcEvolutionCollapsible">
                        <div class="collapsible-header" id="pcEvolutionHeader">
                            <h3>PC Evolution Timeline Images</h3>
                            <i class="fas fa-chevron-right collapsible-icon" id="pcEvolutionIcon"></i>
                        </div>
                        <div class="collapsible-content" id="pcEvolutionContent"> 
                            <div class="pc-evolution-images-grid">
                                <!-- Removed setup1.jpeg and setup6.jpeg -->
                                <img src="images/setup9.jpeg" alt="PC Image 9" onerror="this.onerror=null;this.src='https://placehold.co/250x150/222/FFF?text=Image+Error';">
                                <img src="images/setup8.jpeg" alt="PC Image 8" onerror="this.onerror=null;this.src='https://placehold.co/250x150/222/FFF?text=Image+Error';">
                                <img src="images/setup7.jpeg" alt="PC Image 7" onerror="this.onerror=null;this.src='https://placehold.co/250x150/222/FFF?text=Image+Error';">
                                <img src="images/setup5.jpeg" alt="PC Image 5" onerror="this.onerror=null;this.src='https://placehold.co/250x150/222/FFF?text=Image+Error';">
                                <img src="images/setup4.jpeg" alt="PC Image 4" onerror="this.onerror=null;this.src='https://placehold.co/250x150/222/FFF?text=Image+Error';">
                                <img src="images/setup3.jpeg" alt="PC Image 3" onerror="this.onerror=null;this.src='https://placehold.co/250x150/222/FFF?text=Image+Error';">
                                <img src="images/setup2.jpeg" alt="PC Image 2" onerror="this.onerror=null;this.src='https://placehold.co/250x150/222/FFF?text=Image+Error';">
                            </div>
                        </div>
                    </div>
                </section>
            </div>
        </div>
    </div>

    <div class="nav-dots" id="nav-dots">
        <div class="dot active" data-face="0"></div>
        <div class="dot" data-face="1"></div>
        <div class="dot" data-face="2"></div>
        <div class="dot" data-face="3"></div>
    </div>

    <p class="disclaimer">References available upon request.</p>

    <div id="imageModal" class="modal">
        <span class="close-button">&times;</span>
        <span class="modal-nav-arrow left" id="prevImage">&lt;</span>
        <img class="modal-content" id="modalImage">
        <span class="modal-nav-arrow right" id="nextImage">&gt;</span>
    </div>

    <script>
        // --- Three.js Background Animation Setup ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        const sceneContainer = document.getElementById('scene-container');
        sceneContainer.appendChild(renderer.domElement);

        // Add lights to the scene for visual effect
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
        scene.add(ambientLight);

        const pointLight1 = new THREE.PointLight(0xFF5722, 0.7); // Orange light source
        pointLight1.position.set(5, 5, 5);
        scene.add(pointLight1);

        const pointLight2 = new THREE.PointLight(0xFF8A65, 0.5); // Lighter orange light source
        pointLight2.position.set(-5, -5, -5);
        scene.add(pointLight2);

        // Particle System for Glowing Data Points (background effect)
        const particlesGeometry = new THREE.BufferGeometry();
        const particlesCount = 2000; // Number of particles in the system

        const posArray = new Float32Array(particlesCount * 3); // XYZ coordinates for each particle
        const colorArray = new Float32Array(particlesCount * 3); // RGB colors for each particle

        // Populate particle positions and colors randomly within a cube
        for (let i = 0; i < particlesCount * 3; i += 3) {
            posArray[i] = (Math.random() - 0.5) * 50; // x-coordinate
            posArray[i + 1] = (Math.random() - 0.5) * 50; // y-coordinate
            posArray[i + 2] = (Math.random() - 0.5) * 50; // z-coordinate

            // Random colors for particles (shades of orange/red for thematic consistency)
            colorArray[i] = 0.8 + Math.random() * 0.2; // Red component (0.8 to 1.0)
            colorArray[i + 1] = 0.3 + Math.random() * 0.3; // Green component (0.3 to 0.6)
            colorArray[i + 2] = 0.1 + Math.random() * 0.2; // Blue component (0.1 to 0.3)
        }

        particlesGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colorArray, 3));

        const particlesMaterial = new THREE.PointsMaterial({
            size: 0.1,
            vertexColors: true, // Enable per-vertex colors
            blending: THREE.AdditiveBlending, /* Use additive blending for glowing effect */
            transparent: true,
            sizeAttenuation: true // Particles closer to camera appear larger
        });

        const particles = new THREE.Points(particlesGeometry, particlesMaterial);
        scene.add(particles);

        camera.position.z = 10; // Position the camera back to view the particles

        // Animation loop for Three.js scene (renders frame by frame)
        function animate() {
            requestAnimationFrame(animate); // Request next frame
            particles.rotation.y += 0.0005; // Rotate particles slowly on Y-axis
            particles.rotation.x += 0.0002; // Rotate particles even slower on X-axis
            renderer.render(scene, camera); // Render the scene from the camera's perspective
        }

        // Handle window resizing to keep Three.js scene responsive
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight; // Update camera aspect ratio
            camera.updateProjectionMatrix(); // Recalculate projection matrix
            renderer.setSize(window.innerWidth, window.innerHeight); // Resize renderer output
            setFacePositions(); // Recalculate CSS 3D face positions on resize
            updateSectionContentTop(); // Recalculate content top positions on resize
        });

        // --- CSS 3D Octagonal Prism Rotation Logic ---
        const resumeCube = document.getElementById('resume-cube');
        const dots = document.querySelectorAll('.dot');
        const faces = document.querySelectorAll('.face');
        const sectionContents = document.querySelectorAll('.section-content'); /* Get all scrollable content areas */
        const faceHeaders = document.querySelectorAll('.face-header'); /* Get all face headers */

        // Variables for cube rotation and interaction
        let isDragging = false; // Flag to track if touch-based drag/swipe is active
        let startX; // Stores initial X position for touch drag calculation
        let currentRotateY = 0; // Current Y rotation of the entire prism (continuous value)
        let targetRotateY = 0;  // Target Y rotation for smooth animation (snaps to nearest face)
        const dragRotationSpeed = 0.4; // Increased sensitivity for touch drag for smoother feel
        const transitionInterpolation = 0.1; // Smoothness of interpolation for cube rotation
        let hasDragged = false; // Flag to distinguish a tap from a drag/swipe

        // Keyboard control variables
        let keysPressed = {}; // Stores currently pressed keys for continuous input
        const scrollAmount = 50; // Amount to scroll content by with arrow keys/W/S

        // Touch variables for swipe detection on the cube
        let initialTouchX = 0; // Initial X touch position for swipe direction
        let initialTouchY = 0; // Initial Y touch position for swipe direction
        const swipeThreshold = 50; // Minimum horizontal distance for a recognized swipe
        const swipeVerticalTolerance = 30; // Maximum vertical deviation for a horizontal swipe

        // Function to detect if the device is mobile based on user agent
        function isMobileDevice() {
            return /Mobi|Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        }

        // Define the initial Y rotation offset for each face to form the octagonal prism
        // Each face is rotated 90 degrees relative to the previous one
        const faceYOffsets = {
            'face-0': 0,
            'face-1': 90,
            'face-2': 180,
            'face-3': 270
        };

        // This array stores the target Y rotations for the *entire cube*
        // to bring each specific face to the front.
        const cubeTargetRotations = [
            { y: 0 },     // 0: face-0 (Intro/Objective)
            { y: -90 },   // 1: face-1 (Experience)
            { y: -180 },  // 2: face-2 (About Me)
            { y: -270 }    // 3: face-3 (Hobbies & PC Evolution)
        ];

        let activeFaceIndex = 0; // Keep track of the currently active face (starts at 0)

        // Function to set the initial 3D positions of each face to form the octagonal prism
        function setFacePositions() {
            const cubeWidth = resumeCube.offsetWidth;
            // The apothem is the distance from the center to the midpoint of a side.
            // For a regular octagon, apothem = side / (2 * tan(PI/8)). Here, 0.85 is an approximation
            // to visually position the faces correctly for a 4-sided prism within the cube container.
            const apothem = cubeWidth * 0.85; 

            faces.forEach(face => {
                const faceName = Array.from(face.classList).find(cls => cls.startsWith('face-'));
                if (faceName) {
                    // Apply the fixed rotation and translation for each face to form the octagon
                    face.style.transform = `rotateY(${faceYOffsets[faceName]}deg) translateZ(${apothem}px)`;
                    face.style.transformOrigin = 'center center'; // Ensure rotation is around its center
                }
            });
        }

        // Function to dynamically update the top position of .section-content
        // This ensures content starts below the header, adapting to header height changes.
        function updateSectionContentTop() {
            faceHeaders.forEach((header, index) => {
                // Get the appropriate content gap based on device type
                const contentGap = window.innerWidth <= 768 ? 
                                   parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--content-gap-mobile')) : 
                                   parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--content-gap-desktop'));
                
                const headerBottom = header.offsetTop + header.offsetHeight; // Calculate the bottom edge of the header
                const sectionContent = sectionContents[index]; // Get the corresponding content area
                
                if (sectionContent) {
                    // Set the top of the content area to be below the header, plus the defined content gap
                    sectionContent.style.top = `${headerBottom + contentGap}px`;
                }
            });
        }

        // Applies the current rotation value to the cube element's transform property
        function applyCubeRotation() {
            resumeCube.style.transform = `rotateY(${currentRotateY}deg)`;
        }

        // Navigates the cube to display a specific face by its index
        function goToFace(index) {
            // Calculate the new index, ensuring it wraps around for infinite rotation
            const newIndex = (index + cubeTargetRotations.length * 100) % cubeTargetRotations.length;
            activeFaceIndex = newIndex; // Update the active face index

            // Get the desired Y rotation for the target face
            const desiredFaceRotation = cubeTargetRotations[activeFaceIndex].y;

            // Normalize the current Y rotation to a 0-359 degree range
            let normalizedCurrentY = currentRotateY % 360;
            if (normalizedCurrentY < 0) {
                normalizedCurrentY += 360;
            }

            // Calculate the shortest difference to rotate (clockwise or counter-clockwise)
            let diff = desiredFaceRotation - normalizedCurrentY;
            if (diff > 180) {
                diff -= 360;
            } else if (diff < -180) {
                diff += 360;
            }

            // Add this shortest difference to the actual currentRotateY to set the new target
            targetRotateY = currentRotateY + diff;
            updateActiveDot(); // Update the active navigation dot
        }

        // Updates the visual state of the navigation dots to reflect the active face
        function updateActiveDot() {
            dots.forEach((dot, index) => {
                dot.classList.remove('active'); // Remove 'active' class from all dots
                if (index < cubeTargetRotations.length) {
                    dot.style.display = 'block'; // Ensure dot is visible if it corresponds to a face
                    if (index === activeFaceIndex) {
                        dot.classList.add('active'); // Add 'active' class to the current face's dot
                    }
                } else {
                    dot.style.display = 'none'; // Hide any unused dots (if more dots than faces)
                }
            });
        }

        // Smoothly interpolates the cube's rotation towards the target rotation
        function animateRotation() {
            requestAnimationFrame(animateRotation); // Request the next animation frame

            // Handle keyboard input for direct face transitions (A/D or Left/Right Arrows)
            if (keysPressed['arrowleft'] || keysPressed['a']) {
                goToFace(activeFaceIndex - 1); // Go to previous face
                delete keysPressed['arrowleft']; // Clear key state to prevent continuous rotation
                delete keysPressed['a'];
            } else if (keysPressed['arrowright'] || keysPressed['d']) {
                goToFace(activeFaceIndex + 1); // Go to next face
                delete keysPressed['arrowright']; // Clear key state
                delete keysPressed['d'];
            }

            // Interpolate current rotation towards target rotation for smooth animation
            currentRotateY += (targetRotateY - currentRotateY) * transitionInterpolation;

            // Apply rotation only if there's a significant difference to avoid jittering
            if (Math.abs(targetRotateY - currentRotateY) > 0.01) {
                applyCubeRotation();
            }
        }

        // Snaps the cube to the nearest face based on its current continuous rotation
        function snapCubeToNearestFace() {
            let closestTargetY = 0;
            let minAbsDiff = Infinity;
            let bestIndex = 0;

            // Iterate through all possible target rotations to find the closest one
            for (let i = 0; i < cubeTargetRotations.length; i++) {
                let baseTarget = cubeTargetRotations[i].y;
                // Calculate potential targets by adding multiples of 360 degrees
                // to account for continuous rotation beyond a single 360-degree cycle.
                let potentialTarget1 = baseTarget + Math.floor(currentRotateY / 360) * 360;
                let potentialTarget2 = baseTarget + Math.ceil(currentRotateY / 360) * 360;

                let diff1 = Math.abs(currentRotateY - potentialTarget1);
                let diff2 = Math.abs(currentRotateY - potentialTarget2);

                if (diff1 < minAbsDiff) {
                    minAbsDiff = diff1;
                    closestTargetY = potentialTarget1;
                    bestIndex = i;
                }
                if (diff2 < minAbsDiff) {
                    minAbsDiff = diff2;
                    closestTargetY = potentialTarget2;
                    bestIndex = i;
                }
            }
            targetRotateY = closestTargetY; // Set the target to the closest snap point
            activeFaceIndex = bestIndex; // Update the active face index
            updateActiveDot(); // Update the navigation dots
        }

        // Touch events for mobile devices (on the cube itself) - Handles both drag and swipe
        resumeCube.addEventListener('touchstart', (e) => {
            isDragging = true; // Indicate a touch interaction has started
            startX = e.touches[0].clientX; // Store initial X for continuous drag calculation
            initialTouchX = e.touches[0].clientX; // Store initial X for swipe direction detection
            initialTouchY = e.touches[0].clientY; // Store initial Y for swipe direction detection
            hasDragged = false; // Reset flag to differentiate between tap and drag/swipe
            resumeCube.style.transition = 'none'; // Disable CSS transition for immediate response during drag
        }, { passive: false }); // passive: false is crucial to allow preventDefault for scrolling

        resumeCube.addEventListener('touchmove', (e) => {
            if (!isDragging) return; // Only proceed if a touch interaction is active
            hasDragged = true; // Set flag to indicate movement occurred (not just a tap)

            const currentTouchX = e.touches[0].clientX;
            const currentTouchY = e.touches[0].clientY;

            const diffX = currentTouchX - initialTouchX; // Total horizontal movement from start
            const diffY = currentTouchY - initialTouchY; // Total vertical movement from start

            // Prioritize horizontal movement for cube rotation and prevent vertical page scroll
            if (Math.abs(diffX) > Math.abs(diffY) && Math.abs(diffX) > 5) { // Small threshold to start preventing default
                const dragAngle = (currentTouchX - startX) * dragRotationSpeed;
                currentRotateY = targetRotateY + dragAngle;
                applyCubeRotation();
                e.preventDefault(); // Prevent default page scrolling/swiping
            }
            startX = currentTouchX; // Update startX for the next drag calculation step
        }, { passive: false }); // passive: false is crucial to allow preventDefault

        resumeCube.addEventListener('touchend', (e) => {
            isDragging = false; // End of touch interaction
            resumeCube.style.transition = 'transform 0.5s ease-out'; // Re-enable CSS transition for smooth snap

            const finalTouchX = e.changedTouches[0].clientX; // Get final touch position
            const finalTouchY = e.changedTouches[0].clientY; // Get final touch position

            const diffX = finalTouchX - initialTouchX; // Total X movement from touchstart to touchend
            const diffY = finalTouchY - initialTouchY; // Total Y movement from touchstart to touchend

            // Check if it was a distinct horizontal swipe (significant horizontal movement, minimal vertical)
            if (Math.abs(diffX) > swipeThreshold && Math.abs(diffY) < swipeVerticalTolerance) {
                if (diffX > 0) { // Swiped right (finger moved right)
                    goToFace(activeFaceIndex - 1); // Rotate cube left (to show previous face)
                } else { // Swiped left (finger moved left)
                    goToFace(activeFaceIndex + 1); // Rotate cube right (to show next face)
                }
            } else {
                // If not a distinct swipe, snap to the nearest face (this handles regular drags/taps)
                snapCubeToNearestFace();
            }
            hasDragged = false; // Reset hasDragged when touch ends
            // Reset initial touch coordinates for next interaction
            initialTouchX = 0;
            initialTouchY = 0;
        }, { passive: true }); // passive: true as we don't need to preventDefault in touchend itself

        // Click event for left/right navigation on the document body (for clicks outside the cube)
        document.body.addEventListener('click', (e) => {
            // If a drag/swipe just occurred on the cube, ignore this click to prevent double-triggering
            if (hasDragged) {
                hasDragged = false; // Reset the flag
                return;
            }

            // NEW CHECK: If the click target is inside the modal, do not rotate the cube.
            if (e.target.closest('#imageModal')) {
                return;
            }

            // Original check for clicks inside the cube itself
            if (e.target.closest('#resume-cube')) {
                return; // Do not rotate if clicked inside the cube
            }

            const clickX = e.clientX; // X position relative to the viewport

            if (clickX < window.innerWidth / 2) {
                // Click on the left half of the window (outside the cube)
                goToFace(activeFaceIndex - 1);
            } else {
                // Click on the right half of the window (outside the cube)
                goToFace(activeFaceIndex + 1);
            }
        });

        // Keyboard event listeners for navigation (A/D/Arrows) and content scrolling (W/S/Arrows)
        document.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            const activeContentArea = sectionContents[activeFaceIndex];

            // Cube rotation keys (Left Arrow, Right Arrow, A, D)
            if (['arrowleft', 'arrowright', 'a', 'd'].includes(key)) {
                keysPressed[key] = true; // Mark key as pressed
                e.preventDefault(); // Prevent default browser scroll behavior for arrow keys
            } 
            // Content scrolling keys (Down Arrow, S, Up Arrow, W)
            else if (key === 'arrowdown' || key === 's') {
                e.preventDefault(); // Prevent default page scroll
                if (activeContentArea) {
                    activeContentArea.scrollTop += scrollAmount; // Scroll content down
                }
            } else if (key === 'arrowup' || key === 'w') {
                e.preventDefault(); // Prevent default page scroll
                if (activeContentArea) {
                    activeContentArea.scrollTop -= scrollAmount; // Scroll content up
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            if (['arrowleft', 'arrowright', 'a', 'd'].includes(key)) {
                delete keysPressed[key]; // Release key state
            }
        });

        // Navigation dots functionality to jump to a specific face
        dots.forEach((dot, index) => {
            dot.addEventListener('click', (e) => { // Passed event 'e'
                e.stopPropagation(); // Prevent the click from bubbling up to document.body and causing double rotation
                goToFace(index); // Navigate to the corresponding face
            });
        });

        // --- Typing Text Effect for Objective Section ---
        const objectiveTextElement = document.getElementById('objective-text');
        const objectiveFullText = objectiveTextElement.textContent; // Capture original text content
        objectiveTextElement.textContent = ''; // Clear the text for typing effect
        let objectiveCharIndex = 0; // Index to track current character being typed

        function typeObjectiveText() {
            if (objectiveCharIndex < objectiveFullText.length) {
                objectiveTextElement.textContent += objectiveFullText.charAt(objectiveCharIndex); // Add next character
                objectiveCharIndex++;
                setTimeout(typeObjectiveText, 15); /* Adjusted typing speed to 15ms for quicker appearance */
            }
        }

        // --- Manual Scrolling Logic for .section-content (Mouse Wheel & Touch) ---
        sectionContents.forEach(contentArea => {
            let isScrolling = false; // Flag for touch scrolling
            let startScrollY = 0; // Stores initial scroll position for touch interaction
            let startClientY = 0; // Stores initial touch Y position

            // Mouse wheel scrolling for content areas
            contentArea.addEventListener('wheel', (e) => {
                e.preventDefault(); // Prevent default page scrolling
                // Calculate new scroll position, clamping it between 0 and max scroll height
                const newScrollTop = contentArea.scrollTop + e.deltaY;
                contentArea.scrollTop = Math.max(0, Math.min(newScrollTop, contentArea.scrollHeight - contentArea.clientHeight));
            });

            // Touch scrolling specific to content areas (vertical drag)
            contentArea.addEventListener('touchstart', (e) => {
                // Only initiate content scrolling if it's a single touch (to avoid interfering with pinch-zoom)
                if (e.touches.length === 1) {
                    isScrolling = true;
                    startClientY = e.touches[0].clientY; // Record initial touch Y
                    startScrollY = contentArea.scrollTop; // Record initial scroll position
                }
            }, { passive: false }); // passive: false allows preventDefault

            contentArea.addEventListener('touchmove', (e) => {
                if (!isScrolling) return; // Only proceed if a touch scroll is active
                
                const deltaY = e.touches[0].clientY - startClientY; // Calculate vertical touch movement
                const newScrollTop = startScrollY - deltaY; // Calculate new potential scroll position
                
                // Check if the scroll is within bounds before preventing default
                const willScroll = (newScrollTop >= 0 && newScrollTop <= (contentArea.scrollHeight - contentArea.clientHeight));

                contentArea.scrollTop = Math.max(0, Math.min(newScrollTop, contentArea.scrollHeight - contentArea.clientHeight));
                
                if (willScroll) {
                    e.preventDefault(); // Prevent default page scrolling if content can scroll
                }
            }, { passive: false }); // passive: false allows preventDefault

            contentArea.addEventListener('touchend', () => {
                isScrolling = false; // End of touch scroll interaction
            });
        });

        // --- Collapsible Main Hobbies Logic ---
        const mainHobbiesHeader = document.getElementById('mainHobbiesHeader');
        const mainHobbiesContent = document.getElementById('mainHobbiesContent');
        const mainHobbiesIcon = document.getElementById('mainHobbiesIcon');

        mainHobbiesHeader.addEventListener('click', () => {
            mainHobbiesContent.classList.toggle('active'); // Toggle 'active' class for content visibility
            mainHobbiesIcon.classList.toggle('rotated'); // Toggle 'rotated' class for icon animation
        });

        // --- Collapsible PC Evolution Images Logic ---
        const pcEvolutionHeader = document.getElementById('pcEvolutionHeader');
        const pcEvolutionContent = document.getElementById('pcEvolutionContent');
        const pcEvolutionIcon = document.getElementById('pcEvolutionIcon');

        pcEvolutionHeader.addEventListener('click', () => {
            pcEvolutionContent.classList.toggle('active'); // Toggle 'active' class for content visibility
            pcEvolutionIcon.classList.toggle('rotated'); // Toggle 'rotated' class for icon animation
        });


        // --- Event Listeners and Initializations (runs once when the window loads) ---
        window.onload = function () {
            setFacePositions(); // Initialize face positions for the octagonal prism
            animate(); // Start the Three.js background animation
            animateRotation(); // Start the CSS cube rotation animation loop
            setTimeout(typeObjectiveText, 100); // Start typing for objective after a small delay
            updateActiveDot(); // Set initial active dot
            updateSectionContentTop(); // Initial calculation of content top
        };

        // --- Image Modal Logic with Navigation ---
        const modal = document.getElementById("imageModal");
        const modalImage = document.getElementById("modalImage");
        const closeButton = document.getElementsByClassName("close-button")[0];
        const prevImageBtn = document.getElementById("prevImage");
        const nextImageBtn = document.getElementById("nextImage");
        const pcImagesContainer = document.querySelector(".pc-evolution-images-grid");

        let currentImageIndex = 0;
        let imageSources = []; // To store all image sources from the grid

        // Function to update modal image and navigation button states
        function updateModalImage() {
            modalImage.src = imageSources[currentImageIndex];
            prevImageBtn.classList.toggle('disabled', currentImageIndex === 0);
            nextImageBtn.classList.toggle('disabled', currentImageIndex === imageSources.length - 1);
        }

        // Add click listener to each PC evolution image to open the modal
        // This dynamically collects images on click, useful if images are added/removed
        pcImagesContainer.addEventListener('click', function(event) {
            const clickedImg = event.target.closest('img');
            if (clickedImg) {
                // Populate imageSources array and find current index
                imageSources = Array.from(pcImagesContainer.querySelectorAll('img')).map(img => img.src);
                currentImageIndex = imageSources.indexOf(clickedImg.src);
                
                modal.style.display = "flex"; // Show the modal
                updateModalImage(); // Set modal image and button states
                event.stopPropagation(); // Prevent the click from bubbling up to document.body and causing cube rotation
            }
        });

        // Navigation for modal images
        prevImageBtn.addEventListener('click', (event) => {
            event.stopPropagation(); // Prevent modal from closing
            if (currentImageIndex > 0) {
                currentImageIndex--;
                updateModalImage();
            }
        });

        nextImageBtn.addEventListener('click', (event) => {
            event.stopPropagation(); // Prevent modal from closing
            if (currentImageIndex < imageSources.length - 1) {
                currentImageIndex++;
                updateModalImage();
            }
        });

        // When the modal image itself is clicked, close the modal AND stop propagation
        modalImage.onclick = function(event) {
            event.stopPropagation(); // Prevent the click from bubbling up to document.body and causing cube rotation
            modal.style.display = "none"; // Close the modal when the image itself is clicked
        }

        // Close the modal when the close button is clicked
        closeButton.onclick = function() {
            modal.style.display = "none"; // Hide the modal
        }

        // Close the modal when clicking outside the image content (on the modal overlay itself)
        modal.onclick = function(event) {
            if (event.target == modal) { // This checks if the clicked element is the modal backdrop, not the image or close button
                modal.style.display = "none"; // Hide the modal
            }
        }
    </script>
</body>
</html>
